---
layout: post
authors: [tim_vierbergen,glenn_van_de_putte]
title: 'Cypress: a new kind on the E2E block'
image: /img/cypress/cypress-logo.png
tags: [ci,e2e,javascript,testing,selenium]
category: Testing
comments: true
---

# Table of contents
1. [Intro](#intro)
2. [Cypress](#cypress)
3. [Comparison](#comparison)
4. [Example and Setup](#example-and-setup)
5. [Continuous Integration](#continuous-integration)
6. [Conclusion](#conclusion)

# Intro

For those of us who are familiar with E2E testing a user interface, we all know the struggle.
Not only coding with waits and timeouts but setups that were harder to manage especially when running it on a continuous integration platform.
Maintaining versions, network issues, browser support, ...

For as long as I can remember, there was one constant in this setup!
`Selenium` was always there.
No matter what framework you use, Nightwatch, Protractor, Gauge, Robot, ...
`Selenium` was the man in the middle.
All I can remember from building a selenium setup a few years ago are all the difficulties and frustrations.
Communication was not working, versions were not matching, timeout issues due to network lag, ... .
But still, `Selenium` was a dependency that was needed!

<div style="text-align: center;" >
  <img src="/img/cypress/selenium-setup.png" width="80%">
</div>

Not that I am not grateful for `Selenium` and its team of developers and maintainers, cause let's be honest, what would we have done without it?
But now, Ohh yeah, there's a new kid in town.

# Cypress

> Fast, easy and reliable testing for anything that runs in a browser
~<a target="\_blank" href="https://www.cypress.io/">Cypress</a>

Cypress is aiming to provide its users with a bundled experience for writing end to end tests for web applications.
While lots of other frameworks (as mentioned above) are all interacting over a Selenium server, for remote communication and per se, running its tests outside of the browser, `Cypress` is executed inside of the browser.
Therefore `Cypress` is executed in the same runtime as your application itself.
Because of this, `Cypress` has native access to every single object. The `window`, the `document`, a `DOM`-element, a `service worker`, ... .
`Cypress` does not need to send commands over-the-wire and can just access everything.

# Comparison

|| Selenium | Cypress
| ------------- |:-------------:| :-----:|
| Debugging: | Hard/Remote | Easy/Access to everything/Nice tool
| Speed: | Remote = slow | In browser = Fast
| Parallel: | V | V
| Headless: | V | V
| Language support: |  Java, Perl PHP, Python, Ruby, C#, Javascript | Javascript
| Browser support: | Everything | Only webkit


## Basic architecture

Cypress consists of a few different building block.
One of them is its own `Nodejs` process.
You can look at this as being a backend.
This backend then launches a browser window and sets-up a proxy to this browser window and sets the domain to localhost.
The browser window has two `iframes` inside.
One is for cypress itself.
The second will hold the application to test.
To make it possible to communicate with the application's iframe, it injects a `<script>`-tag that also sets this to localhost.
Because now both iframes are running on 'localhost', it is possible to access everything of the application.

<div style="text-align: center;" >
  <img src="/img/cypress/cypress-setup.png" width="80%">
</div>

The proxy is proxying all requests from the web-application itself to its backend.
Because the proxy is part of the `Cypress`-setup, `Cypress` can act as the man in the middle and spy on, mock or modify the requests and responses.

Communication between the `Cypress` Nodejs-backend and the `Cypress` iframe, that is running the tests, is via a `websocket`.

There are a few downfalls as seen in the comparison.
Because Cypress is running inside of the browser, the language is `Javascript`.
`Cypress` tests are written using Mocha and Chai.

## Running cypress



## Debugging with Cypress


# Example and setup
# Continuous integration
# Conclusion
